<?xml version="1.0" encoding="UTF-8" ?>
<grammar id="public.swift-source" format-version="1.0" version="1.0" extends="public.source-code">

	<rules>

		<!-- Lexer Rules -->

		<rule id="DOCUMENTATION_BLOCK" precedence="&lt;WHITESPACE,&gt;STRING" options="multiline">
			<definition>((ONE_LINE_DOCUMENTATION | MULTILINE_DOCUMENTATION) (WHITESPACE | NEWLINE)*)+</definition>
		</rule>
		<rule id="COMMENT_BLOCK" precedence="&lt;DOCUMENTATION_BLOCK,&gt;STRING" options="multiline">
			<definition>((ONE_LINE_COMMENT | MULTILINE_COMMENT) (WHITESPACE | NEWLINE)*)+</definition>
		</rule>

		<rule id="NIL_COALESCING_OPERATOR" precedence="=OPERATOR" options="">
			<definition>'\?\?'</definition>
		</rule>
		<rule id="NIL_WRAPPER_POSTFIX" precedence="&lt;NIL_COALESCING_OPERATOR" options="">
			<definition>OPTIONAL_WRAPPER | STRICT_WRAPPER</definition>
		</rule>

		<rule id="RETURN_OPERATOR" precedence="&lt;STRING,&gt;GT_OPERATOR,&gt;SUB_OPERATOR" options="">
			<definition>'\-&gt;'</definition>
		</rule>

		<rule id="NAMESPACE" precedence="&gt;ID,&lt;KEYWORD" options="">
			<definition>(ID '\.')+ ID</definition>
		</rule>

		<rule id="ANNOTATION" precedence="&gt;ID,&lt;KEYWORD" options="">
			<definition>'@[\p{L}]+' (L_PAREN (STRING COMMA)* STRING R_PAREN)?</definition>
		</rule>
		
		<rule id="KEYWORD" precedence="&lt;TOKEN,&lt;OPERATOR,&lt;NUMBER" options="">
			<definition>
				<word>
					<string>associatedtype</string>
					<description>When defining a protocol, it’s sometimes useful to declare one or more associated types as part of the protocol’s definition. An associated type gives a placeholder name to a type that is used as part of the protocol. The actual type to use for that associated type isn’t specified until the protocol is adopted. Associated types are specified with the associatedtype keyword.</description>
					<metadata>
						<reference>https://docs.swift.org/swift-book/LanguageGuide/Generics.html#ID189</reference>
					</metadata>
				</word>
				<word>as</word>
				<word>break</word>
				<word>case</word>
				<word>catch</word>
				<word>class</word>
				<word>continue</word>
				<word>default</word>
				<word>deinit</word>
				<word>do</word>
				<word>else</word>
				<word>enum</word>
				<word>extension</word>
				<word>fallthrough</word>
				<word>false</word>
				<word>fileprivate</word>
				<word>final</word>
				<word>for</word>
				<word>func</word>
				<word>guard</word>
				<word>if</word>
				<word>import</word>
				<word>init</word>
				<word>inout</word>
				<word>internal</word>
				<word>in</word>
				<word>is</word>
				<word>lazy</word>
				<word>let</word>
				<word>nil</word>
				<word>open</word>
				<word>operator</word>
				<word>private</word>
				<word>protocol</word>
				<word>public</word>
				<word>repeat</word>
				<word>return</word>
				<word>self</word>
				<word>static</word>
				<word>struct</word>
				<word>subscript</word>
				<word>super</word>
				<word>switch</word>
				<word>throws</word>
				<word>throw</word>
				<word>try</word>
				<word>true</word>
				<word>typealias</word>
				<word>var</word>
				<word>weak</word>
				<word>where</word>
				<word>while</word>
			</definition>
		</rule>

		<!-- Omitted Lexer Rules -->

		<rule id="OPTIONAL_WRAPPER" options="omit">
			<definition>'\?'</definition>
		</rule>
		<rule id="STRICT_WRAPPER" options="omit">
			<definition>'\!'</definition>
		</rule>

		<rule id="ONE_LINE_DOCUMENTATION" options="omit">
			<definition>'\/\/\/.*'</definition>
		</rule>
		<rule id="ONE_LINE_COMMENT" options="omit">
			<definition>'\/\/.*'</definition>
		</rule>

		<rule id="MULTILINE_DOCUMENTATION" options="omit">
			<definition>'\/\*(?s:.*?)(\*\/|\Z)'</definition>
		</rule>
		<rule id="MULTILINE_COMMENT" options="omit">
			<definition>'\/\*(?s:.*?)(\*\/|\Z)'</definition>
		</rule>

		<!-- Parser Rules -->

		<rule id="import_statement" precedence="&gt;expression" options="">
			<definition>'import' (NAMESPACE | ID)</definition>
		</rule>

		<rule id="declaration" precedence="&gt;expression" options="skip"></rule>

		<rule id="enum_declaration" precedence="=declaration" options="">
			<definition>(ANNOTATION | DOCUMENTATION_BLOCK)*
				access_modifier* 'enum' ID type_extension? BLOCK</definition>
		</rule>
		<rule id="struct_declaration" precedence="=declaration" options="">
			<definition>(ANNOTATION | DOCUMENTATION_BLOCK)*
				access_modifier* 'struct' ID type_extension? BLOCK</definition>
		</rule>
		<rule id="class_declaration" precedence="=declaration" options="">
			<definition>(ANNOTATION | DOCUMENTATION_BLOCK)*
				access_modifier* 'class' ID type_extension? BLOCK</definition>
		</rule>
		<rule id="class_extension" precedence="=declaration" options="">
			<definition>(ANNOTATION | DOCUMENTATION_BLOCK)*
				'extension' ID type_extension? BLOCK</definition>
		</rule>
		<rule id="constructor_declaration" precedence="=declaration" options="">
			<definition>(ANNOTATION | DOCUMENTATION_BLOCK)*
				access_modifier* 'init' L_PAREN parameters? R_PAREN BLOCK</definition>
		</rule>
		<rule id="method_declaration" precedence="=declaration" options="">
			<definition>(ANNOTATION | DOCUMENTATION_BLOCK)*
				access_modifier* 'func' ID L_PAREN parameters? R_PAREN (RETURN_OPERATOR
				(builtin_datatype | ID))? ('throws')? BLOCK</definition>
		</rule>
		<rule id="variable_declaration" precedence="=declaration" options="">
			<definition>(ANNOTATION | DOCUMENTATION_BLOCK)*
				access_modifier* variable_declaration_keyword ID
				rhs_assignment_clause?</definition>
		</rule>

		<rule id="for_loop" precedence="&gt;expression" options="">
			<definition>'for' for_loop_expression BLOCK</definition>
		</rule>
		<rule id="while_loop" precedence="=for_loop" options="">
			<definition>'while' 'let'? expression BLOCK</definition>
		</rule>
		<rule id="repeat_loop" precedence="=for_loop" options="">
			<definition>'repeat'</definition>
		</rule>

		<rule id="method_invocation" precedence="&gt;expression" options="">
			<definition>(NAMESPACE | ID) L_PAREN arguments? R_PAREN</definition>
		</rule>

		<rule id="assignment_clause" precedence="&gt;expression" options="">
			<definition>lhs_assignment_clause rhs_assignment_clause</definition>
		</rule>

		<rule id="expression" precedence="" options="">
			<definition>opened_expression (operator opened_expression)*</definition>
		</rule>

		<!-- Omitted Parser Rules -->

		<rule id="access_modifier" options="omit">
			<definition>'fileprivate' | 'final' | 'lazy' | 'private' | 'open' | 'override' | 'public' | 'static' | 'weak'</definition>
		</rule>
		<rule id="builtin_datatype" options="omit">
			<definition>'Bool' | 'Double' | 'Float' | 'String' | 'Int' | 'Void'</definition>
		</rule>
		<rule id="builtin_value" options="omit">
			<definition>'false' | 'nil' | 'true'</definition>
		</rule>

		<rule id="variable_declaration_keyword" options="omit">
			<definition>'let' | 'var'</definition>
		</rule>
		<rule id="datatype" options="omit">
			<definition>(builtin_datatype | ID) NIL_WRAPPER_POSTFIX?</definition>
		</rule>
		<rule id="datavalue" options="omit">
			<definition>builtin_value | method_invocation | KEYWORD | STRING | LITERAL_STRING | NUMBER | NAMESPACE | ID</definition>
		</rule>
		<rule id="operator" options="omit,extend">
			<definition>NIL_COALESCING_OPERATOR</definition>
		</rule>
		<rule id="type_extension" options="omit">
			<definition>':' datatype (COMMA datatype)*</definition>
		</rule>

		<rule id="variable_accessor" options="omit">
			<definition>datavalue (':' datatype)?</definition>
		</rule>
		<rule id="array_accessor" options="omit">
			<definition>datavalue L_BRACKET datavalue R_BRACKET</definition>
		</rule>

		<rule id="lhs_assignment_clause" options="omit">
			<definition>array_accessor | variable_accessor</definition>
		</rule>
		<rule id="rhs_assignment_clause" options="omit">
			<definition>(EQ_ASSIGNMENT_OPERATOR | INCREMENTAL_ASSIGNMENT_OPERATOR) expression</definition>
		</rule>

		<rule id="simple_expression" options="omit">
			<definition>datavalue (operator datavalue)?</definition>
		</rule>
		<rule id="opened_expression" options="omit">
			<definition>(closed_expression | simple_expression) typecast?</definition>
		</rule>
		<rule id="closed_expression" options="omit">
			<definition>L_PAREN opened_expression R_PAREN</definition>
		</rule>
		<rule id="typecast" precedence="" options="omit">
			<definition>'as' NIL_WRAPPER_POSTFIX? datatype</definition>
		</rule>

		<rule id="for_loop_expression" options="omit">
			<definition>ID 'in' ID | expression</definition>
		</rule>

		<rule id="parameter" options="omit">
			<definition>'_'? ID ':' datatype</definition>
		</rule>
		<rule id="parameters" options="omit">
			<definition>parameter (COMMA parameter)*</definition>
		</rule>

		<rule id="argument" options="omit">
			<definition>(ID ':')? datavalue</definition>
		</rule>
		<rule id="arguments" options="omit">
			<definition>argument (COMMA argument)*</definition>
		</rule>

	</rules>
    
    <events>
        
    </events>
    
    <sequences>
        
    </sequences>

</grammar>
