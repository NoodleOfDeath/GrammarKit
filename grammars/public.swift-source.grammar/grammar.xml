<?xml version="1.0" encoding="UTF-8" ?>
<grammar id="public.swift-source" format-version="1.0" version="1.0" extends="public.source-code">

	<rules>

		<!-- Lexer Rules -->

		<rule id="NAMESPACE" precedence="5000" options="">
			<definition>(ID '\.')+ ID</definition>
		</rule>

		<rule id="ANNOTATION" precedence="5000" options="">
			<definition>'@[\p{L}]+' (L_PAREN (STRING COMMA)* STRING R_PAREN)?
			</definition>
		</rule>
		
		<rule id="KEYWORD" precedence="10000" options="">
			<definition>
				<word>associatedtype</word>
				<word>as</word>
				<word>break</word>
				<word>case</word>
				<word>catch</word>
				<word>class</word>
				<word>continue</word>
				<word>default</word>
				<word>deinit</word>
				<word>do</word>
				<word>else</word>
				<word>enum</word>
				<word>extension</word>
				<word>fallthrough</word>
				<word>false</word>
				<word>fileprivate</word>
				<word>final</word>
				<word>for</word>
				<word>func</word>
				<word>guard</word>
				<word>if</word>
				<word>import</word>
				<word>init</word>
				<word>inout</word>
				<word>internal</word>
				<word>in</word>
				<word>is</word>
				<word>lazy</word>
				<word>let</word>
				<word>nil</word>
				<word>open</word>
				<word>operator</word>
				<word>private</word>
				<word>protocol</word>
				<word>public</word>
				<word>repeat</word>
				<word>return</word>
				<word>self</word>
				<word>static</word>
				<word>struct</word>
				<word>subscript</word>
				<word>super</word>
				<word>switch</word>
				<word>throws</word>
				<word>throw</word>
				<word>try</word>
				<word>true</word>
				<word>typealias</word>
				<word>var</word>
				<word>weak</word>
				<word>where</word>
				<word>while</word>
			</definition>
		</rule>

		<rule id="ONE_LINE_DOCUMENTATION" precedence="10000" options="">
			<definition>'\/\/\/.*'</definition>
		</rule>
		<rule id="ONE_LINE_COMMENT" precedence="10000" options="">
			<definition>'\/\/.*'</definition>
		</rule>
		<rule id="BLOCK_DOCUMENTATION" precedence="10000" options="">
			<definition>'\/\*(?s:.*?)(\*\/|\Z)'</definition>
		</rule>
		<rule id="BLOCK_COMMENT" precedence="10000" options="">
			<definition>'\/\*(?s:.*?)(\*\/|\Z)'</definition>
		</rule>

		<rule id="OPTIONAL_WRAPPER" precedence="2300" options="omit">
			<definition>'\?'</definition>
		</rule>
		<rule id="STRICT_WRAPPER" precedence="2300" options="omit">
			<definition>'\!'</definition>
		</rule>

		<!-- Parser Rules -->

		<rule id="import_statement" precedence="6000" options="">
			<definition>'import' (NAMESPACE | ID)</definition>
		</rule>

		<rule id="enum_declaration" precedence="7000" options="">
			<definition>(ANNOTATION | ONE_LINE_DOCUMENTATION | BLOCK_DOCUMENTATION)*
				access_modifier* 'enum' ID type_extension? BLOCK
			</definition>
		</rule>
		<rule id="struct_declaration" precedence="=enum_declaration" options="">
			<definition>(ANNOTATION | ONE_LINE_DOCUMENTATION | BLOCK_DOCUMENTATION)*
				access_modifier* 'struct' ID type_extension? BLOCK
			</definition>
		</rule>
		<rule id="class_declaration" precedence="=enum_declaration" options="">
			<definition>(ANNOTATION | ONE_LINE_DOCUMENTATION | BLOCK_DOCUMENTATION)*
				access_modifier* 'class' ID type_extension? BLOCK
			</definition>
		</rule>
		<rule id="class_extension" precedence="=enum_declaration" options="">
			<definition>(ANNOTATION | ONE_LINE_DOCUMENTATION | BLOCK_DOCUMENTATION)*
				'extension' ID type_extension? BLOCK
			</definition>
		</rule>
		<rule id="constructor_declaration" precedence="=enum_declaration" options="">
			<definition>(ANNOTATION | ONE_LINE_DOCUMENTATION | BLOCK_DOCUMENTATION)*
				access_modifier* 'init' L_PAREN parameters? R_PAREN BLOCK
			</definition>
		</rule>
		<rule id="method_declaration" precedence="=enum_declaration" options="">
			<definition>(ANNOTATION | ONE_LINE_DOCUMENTATION | BLOCK_DOCUMENTATION)*
				access_modifier* 'func' ID L_PAREN parameters? R_PAREN (RETURN_OPERATOR
				(builtin_datatype | ID))? ('throws')? BLOCK
			</definition>
		</rule>
		<rule id="variable_declaration" precedence="=enum_declaration" options="">
			<definition>(ANNOTATION | ONE_LINE_DOCUMENTATION | BLOCK_DOCUMENTATION)*
				access_modifier* variable_declaration_keyword ID
				rhs_assignment_clause?
			</definition>
		</rule>

		<rule id="for_loop" precedence="20000" options="">
			<definition>'for' for_loop_expression BLOCK</definition>
		</rule>
		<rule id="while_loop" precedence="=for_loop" options="">
			<definition>'while' 'let'? expression BLOCK</definition>
		</rule>
		<rule id="repeat_loop" precedence="=for_loop" options="">
			<definition>'repeat'</definition>
		</rule>

		<rule id="method_invocation" precedence="20000" options="">
			<definition>(NAMESPACE | ID) L_PAREN arguments? R_PAREN</definition>
		</rule>

		<rule id="lhs_assignment_clause" precedence="2000" options="">
			<definition>array_accessor | variable_accessor
			</definition>
		</rule>

		<rule id="rhs_assignment_clause" precedence="2000" options="">
			<definition>EQ_ASSIGN_OP expression
			</definition>
		</rule>

		<rule id="assignment_clause" precedence="2000" options="">
			<definition>lhs_assignment_clause rhs_assignment_clause
			</definition>
		</rule>

		<rule id="access_modifier" precedence="0" options="omit">
			<definition>'fileprivate' | 'final' | 'lazy' | 'private' | 'open' |
				'override' | 'public'
				| 'static' | 'weak'
			</definition>
		</rule>
		<rule id="builtin_datatype" precedence="0" options="omit">
			<definition>'Bool' | 'Double' | 'Float' | 'String' | 'Int' | 'Void'
			</definition>
		</rule>
		<rule id="builtin_value" precedence="0" options="omit">
			<definition>'false' | 'nil' | 'true'</definition>
		</rule>

		<rule id="variable_declaration_keyword" precedence="0" options="omit">
			<definition>'let' | 'var'</definition>
		</rule>
		<rule id="datatype" precedence="0" options="omit">
			<definition>(builtin_datatype | ID) NIL_WRAPPER_POSTFIX?</definition>
		</rule>
		<rule id="datavalue" precedence="0" options="omit">
			<definition>builtin_value | method_invocation | KEYWORD | STRING |
				LITERAL_STRING | NUMBER | NAMESPACE | ID
			</definition>
		</rule>
		<rule id="operator" precedence="0" options="omit">
			<definition>LT_OPERATOR | GT_OPERATOR | NIL_COALESCING_OPERATOR</definition>
		</rule>
		<rule id="type_extension" precedence="0" options="omit">
			<definition>':' datatype (COMMA datatype)*</definition>
		</rule>

		<rule id="variable_accessor" precedence="0" options="omit">
			<definition>datavalue (':' datatype)?</definition>
		</rule>
		<rule id="array_accessor" precedence="0" options="omit">
			<definition>datavalue L_BRACKET datavalue R_BRACKET</definition>
		</rule>

		<rule id="expression" precedence="0" options="omit">
			<definition>closed_expression | opened_expression</definition>
		</rule>
		<rule id="simple_expression" precedence="0" options="omit">
			<definition>datavalue (operator datavalue)?</definition>
		</rule>
		<rule id="opened_expression" precedence="0" options="omit">
			<definition>closed_expression | simple_expression</definition>
		</rule>
		<rule id="closed_expression" precedence="0" options="omit">
			<definition>L_PAREN opened_expression R_PAREN</definition>
		</rule>

		<rule id="for_loop_expression" precedence="0" options="omit">
			<definition>ID 'in' ID | expression</definition>
		</rule>

		<rule id="parameter" precedence="0" options="omit">
			<definition>'_'? ID ':' datatype</definition>
		</rule>
		<rule id="parameters" precedence="0" options="omit">
			<definition>parameter (COMMA parameter)*</definition>
		</rule>

		<rule id="argument" precedence="0" options="omit">
			<definition>(ID ':')? datavalue</definition>
		</rule>
		<rule id="arguments" precedence="0" options="omit">
			<definition>argument (COMMA argument)*</definition>
		</rule>

	</rules>
    
    <events>
        
    </events>
    
    <sequences>
        
    </sequences>

</grammar>
