<?xml version="1.0" encoding="UTF-8" ?>
<grammar id="public.swift-source" format-version="1.0" version="1.0" extends="public.source-code">

	<rules>

		<!-- Lexer Rules -->

		<rule id="ONE_LINE_DOCUMENTATION" precedence="10000" options="omit">
			<definition>'\/\/\/.*'</definition>
		</rule>
		<rule id="ONE_LINE_COMMENT" precedence="10000" options="omit">
			<definition>'\/\/.*'</definition>
		</rule>

		<rule id="BLOCK_DOCUMENTATION" precedence="10000" options="omit">
			<definition>'\/\*(?s:.*?)(\*\/|\Z)'</definition>
		</rule>
		<rule id="BLOCK_COMMENT" precedence="10000" options="omit">
			<definition>'\/\*(?s:.*?)(\*\/|\Z)'</definition>
		</rule>

		<rule id="DOCUMENTATION_BLOCK" precedence="max" options="">
			<definition>((ONE_LINE_DOCUMENTATION }| BLOCK_DOCUMENTATION) (WHITESPACE | NEWLINE)*)+</definition>
		</rule>
		<rule id="COMMENT_BLOCK" precedence="max,&lt;DOCUMENTATION_BLOCK" options="">
			<definition>((ONE_LINE_COMMENT | BLOCK_COMMENT) (WHITESPACE | NEWLINE)*)+</definition>
		</rule>

		<rule id="OPTIONAL_WRAPPER" precedence="2300" options="omit">
			<definition>'\?'</definition>
		</rule>
		<rule id="STRICT_WRAPPER" precedence="2300" options="omit">
			<definition>'\!'</definition>
		</rule>

		<rule id="NIL_COALESCING_OPERATOR" precedence="2300" options="">
			<definition>'\?\?'</definition>
		</rule>

		<rule id="NIL_WRAPPER_POSTFIX" precedence="2300" options="">
			<definition>OPTIONAL_WRAPPER | STRICT_WRAPPER</definition>
		</rule>

		<rule id="RETURN_OPERATOR" precedence="2200" options="">
			<definition>'\-&gt;'</definition>
		</rule>

		<rule id="NAMESPACE" precedence="5000" options="">
			<definition>(ID '\.')+ ID</definition>
		</rule>

		<rule id="ANNOTATION" precedence="5000" options="">
			<definition>'@[\p{L}]+' (L_PAREN (STRING COMMA)* STRING R_PAREN)?</definition>
		</rule>
		
		<rule id="KEYWORD" precedence="10000" options="">
			<definition>
				<word>as</word>
				<word>
					<string>associatedtype</string>
					<description>When defining a protocol, it’s sometimes useful to declare one or more associated types as part of the protocol’s definition. An associated type gives a placeholder name to a type that is used as part of the protocol. The actual type to use for that associated type isn’t specified until the protocol is adopted. Associated types are specified with the associatedtype keyword. See https://docs.swift.org/swift-book/LanguageGuide/Generics.html#ID189</description>
				</word>
				<word>break</word>
				<word>case</word>
				<word>catch</word>
				<word>class</word>
				<word>continue</word>
				<word>default</word>
				<word>deinit</word>
				<word>do</word>
				<word>else</word>
				<word>enum</word>
				<word>extension</word>
				<word>fallthrough</word>
				<word>false</word>
				<word>fileprivate</word>
				<word>final</word>
				<word>for</word>
				<word>func</word>
				<word>guard</word>
				<word>if</word>
				<word>import</word>
				<word>in</word>
				<word>init</word>
				<word>inout</word>
				<word>internal</word>
				<word>is</word>
				<word>lazy</word>
				<word>let</word>
				<word>nil</word>
				<word>open</word>
				<word>operator</word>
				<word>private</word>
				<word>protocol</word>
				<word>public</word>
				<word>repeat</word>
				<word>return</word>
				<word>self</word>
				<word>static</word>
				<word>struct</word>
				<word>subscript</word>
				<word>super</word>
				<word>switch</word>
				<word>throws</word>
				<word>throw</word>
				<word>try</word>
				<word>true</word>
				<word>typealias</word>
				<word>var</word>
				<word>weak</word>
				<word>where</word>
				<word>while</word>
			</definition>
		</rule>

		<!-- Parser Rules -->

		<rule id="import_statement" precedence="6000" options="">
			<definition>'import' (NAMESPACE | ID)</definition>
		</rule>

		<rule id="enum_declaration" precedence="7000" options="">
			<definition>(ANNOTATION | DOCUMENTATION_BLOCK)*
				access_modifier* 'enum' ID type_extension? BLOCK</definition>
		</rule>
		<rule id="struct_declaration" precedence="=enum_declaration" options="">
			<definition>(ANNOTATION | DOCUMENTATION_BLOCK)*
				access_modifier* 'struct' ID type_extension? BLOCK</definition>
		</rule>
		<rule id="class_declaration" precedence="=enum_declaration" options="">
			<definition>(ANNOTATION | DOCUMENTATION_BLOCK)*
				access_modifier* 'class' ID type_extension? BLOCK</definition>
		</rule>
		<rule id="class_extension" precedence="=enum_declaration" options="">
			<definition>(ANNOTATION | DOCUMENTATION_BLOCK)*
				'extension' ID type_extension? BLOCK</definition>
		</rule>
		<rule id="constructor_declaration" precedence="=enum_declaration" options="">
			<definition>(ANNOTATION | DOCUMENTATION_BLOCK)*
				access_modifier* 'init' L_PAREN parameters? R_PAREN BLOCK</definition>
		</rule>
		<rule id="method_declaration" precedence="=enum_declaration" options="">
			<definition>(ANNOTATION | DOCUMENTATION_BLOCK)*
				access_modifier* 'func' ID L_PAREN parameters? R_PAREN (RETURN_OPERATOR
				(builtin_datatype | ID))? ('throws')? BLOCK</definition>
		</rule>
		<rule id="variable_declaration" precedence="=enum_declaration" options="">
			<definition>(ANNOTATION | DOCUMENTATION_BLOCK)*
				access_modifier* variable_declaration_keyword ID
				rhs_assignment_clause?</definition>
		</rule>

		<rule id="for_loop" precedence="20000" options="">
			<definition>'for' for_loop_expression BLOCK</definition>
		</rule>
		<rule id="while_loop" precedence="=for_loop" options="">
			<definition>'while' 'let'? expression BLOCK</definition>
		</rule>
		<rule id="repeat_loop" precedence="=for_loop" options="">
			<definition>'repeat'</definition>
		</rule>

		<rule id="method_invocation" precedence="20000" options="">
			<definition>(NAMESPACE | ID) L_PAREN arguments? R_PAREN</definition>
		</rule>

		<rule id="lhs_assignment_clause" precedence="2000" options="">
			<definition>array_accessor | variable_accessor</definition>
		</rule>

		<rule id="rhs_assignment_clause" precedence="2000" options="">
			<definition>EQ_ASSIGNMENT_OPERATOR expression</definition>
		</rule>

		<rule id="assignment_clause" precedence="2000" options="">
			<definition>lhs_assignment_clause rhs_assignment_clause</definition>
		</rule>

		<!-- Fragment Rules -->

		<rule id="access_modifier" options="omit">
			<definition>'fileprivate' | 'final' | 'lazy' | 'private' | 'open' | 'override' | 'public' | 'static' | 'weak'</definition>
		</rule>
		<rule id="builtin_datatype" options="omit">
			<definition>'Bool' | 'Double' | 'Float' | 'String' | 'Int' | 'Void'</definition>
		</rule>
		<rule id="builtin_value" options="omit">
			<definition>'false' | 'nil' | 'true'</definition>
		</rule>

		<rule id="variable_declaration_keyword" options="omit">
			<definition>'let' | 'var'</definition>
		</rule>
		<rule id="datatype" options="omit">
			<definition>(builtin_datatype | ID) NIL_WRAPPER_POSTFIX?</definition>
		</rule>
		<rule id="datavalue" options="omit">
			<definition>builtin_value | method_invocation | KEYWORD | STRING | LITERAL_STRING | NUMBER | NAMESPACE | ID</definition>
		</rule>
		<rule id="operator" options="omit">
			<definition>BITWISE_OPERATOR | LOGIC_OPERATOR | LT_OPERATOR | GT_OPERATOR | EQ_OPERATOR | NIL_COALESCING_OPERATOR</definition>
		</rule>
		<rule id="type_extension" options="omit">
			<definition>':' datatype (COMMA datatype)*</definition>
		</rule>

		<rule id="variable_accessor" options="omit">
			<definition>datavalue (':' datatype)?</definition>
		</rule>
		<rule id="array_accessor" options="omit">
			<definition>datavalue L_BRACKET datavalue R_BRACKET</definition>
		</rule>

		<rule id="expression" options="omit">
			<definition>closed_expression | opened_expression</definition>
		</rule>
		<rule id="simple_expression" options="omit">
			<definition>datavalue (operator datavalue)?</definition>
		</rule>
		<rule id="opened_expression" options="omit">
			<definition>closed_expression | simple_expression</definition>
		</rule>
		<rule id="closed_expression" options="omit">
			<definition>L_PAREN opened_expression R_PAREN</definition>
		</rule>

		<rule id="for_loop_expression" options="omit">
			<definition>ID 'in' ID | expression</definition>
		</rule>

		<rule id="parameter" options="omit">
			<definition>'_'? ID ':' datatype</definition>
		</rule>
		<rule id="parameters" options="omit">
			<definition>parameter (COMMA parameter)*</definition>
		</rule>

		<rule id="argument" options="omit">
			<definition>(ID ':')? datavalue</definition>
		</rule>
		<rule id="arguments" options="omit">
			<definition>argument (COMMA argument)*</definition>
		</rule>

	</rules>
    
    <events>
        
    </events>
    
    <sequences>
        
    </sequences>

</grammar>
